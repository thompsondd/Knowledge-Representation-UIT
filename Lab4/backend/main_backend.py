# -*- coding: utf-8 -*-
"""lab_script_KR.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1R9GKcq5kVBUGNYV7Vu7N6eIEO-HB8Whf
"""
from backend.parse_query import *
from backend.definition_elements import *

class Manage:
  def __init__(self, input_rela, input_value):
    self.value_list = ParseValue(input_value)
    self.info_rela = ParseRela(input_rela)
    self.rela_list = None
    self.validation_condition = {
        "P":[("V"),("E")],
        "S":[("V"),("E")],
        "V":[("O","C")],
        "E":[("O","C")],
    }
    self. rules = {
        "S":self.create_Series,
        "OC":self.package,
        "P": self.create_Parallel
    }
  def get_R(self):
    if self.rela_list==None:
      self.parse()
    return self.rela_list.get_R()
  def get_draw(self):
    if self.rela_list==None:
      self.parse()
    s,e,l,d = self.rela_list.get_draw()
    m = schemdraw.Drawing()
    m+=elm.Dot()
    m+=elm.ElementDrawing(d)
    m+=elm.Dot()
    m.save("./images/plot_circuit.png")
    return m

  def create_relation(self, type_relation, label1, label2,*arg):
    temp = {}
    for i in self.value_list.data:
      #print(f"\t\t\t\t\tRi: {i.label}")
      if label1 == i.label:
        temp.update({"0":i})
      if label2 == i.label:
        temp.update({"1":i})
    #print(f"\t\t\t\ttemp: {temp}")
    if self.rela_list == None and len(list(temp.keys()))<2:
      print("Error 1")
    if len(list(temp.keys()))<2:
      if self.rela_list.label == label1:
        self.rela_list = type_relation(self.rela_list,*list(temp.values()))
        return self.rela_list
      elif self.rela_list.label == label2:
        self.rela_list = type_relation(*list(temp.values()),self.rela_list)
        return self.rela_list
      else:
         print("Error 2")
    if self.rela_list == None:
      self.rela_list = type_relation(*list(temp.values()))
      return self.rela_list
    else:
      print("Error 3")
  
  def create_Series(self,label1, label2,*arg):
    #print(f"\t\t\tcreate_Series:{[label1, label2,*arg]}")
    return self.create_relation(Series, label1, label2)

  def create_Parallel(self, label1, label2,*arg):
    #print(f"\t\t\tcreate_Parallel:{[label1, label2,*arg]}")
    return self.create_relation(Parallel,label1, label2)
  def package(self,*arg):
    #print(f"\t\t\tpackage:{[*arg]}")
    return self.rela_list

  def validate(self,list_ele):
    alpha = ["O","C"]
    beta = ["E","V"]
    a,b,c = list_ele
    if b[1] in ["P","S"]:
      return (a[1] in beta and c[1] in beta,b[1])
    elif b[1] in ["V","E"]:
      return (a[1]==alpha[0] and c[1]==alpha[1],"OC")
    return False,None

  def identify_rela(self, list_ele):
    check, type_rela = self.validate(list_ele)
    #print(f"\t\tidentify_rela:{list_ele}")
    #print(f"\t\tcheck:{check}")
    #print(f"\t\ttype_rela:{type_rela}")
    if check:
      a,b,c = list_ele
      d = self.rules[type_rela](a[0],c[0],b[0])
      #print(f"\t\t\td: {d}")
      if d!=None:
        return (d.label,"E")
    return None

  def parse(self):
    t = [i for i in self.info_rela.lex()]
    index = 0
    while index < len(t):
      index+=1
      if index<3:
        continue
      #print(f"index: {index}")
      start = index-3
      while start>-1:
        #print(f"t: {t}")
        #print(f"\tparse:{t[start:start+3]} - start: {start}")
        a = self.identify_rela(t[start:start+3])
        if a!=None:
          for _ in range(3):
            t.pop(start)
            index -=1
          t.insert(start,a)
          start = index
        start -=1
    #print(f"t: {t}")